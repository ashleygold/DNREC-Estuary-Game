package g4.beachGame.model;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Timer;
import java.util.TimerTask;

import g4.beachGame.controller.BeachCont;

public class Board {
	/** the amount of seconds that is equals 1 hour on the time of the game**/
	final static int GAMESEC_PER_HOUR = 5; //sun time bar has 12 notches.
	
	/**width of the board**/
	final static int WIDTH = 1100; 
	
	/**width of the shore (not including the last column reserved for protectors)**/
	public final static int SHORE_WIDTH = WIDTH-100; 

	/**the number of spots along the shore where the user can place protectors**/
	public final static int SPACES_OF_SHORE = 12;
	
	/**height of the board**/
	public final static int HEIGHT = 600;
	
	/**where the shoreline starts**/
	public final static int SHORE_HEIGHT = HEIGHT/2;
	
	/**whether or not the a spot along the shore has receded to the bottom of the screen**/
	private boolean isShoreDestroyed = false; 
	
	/**which protect is currently being used placed**/
	private int protector = -1;
	
	/**the width of the user, which may change depending on the state**/
	public int user_width = 100;
	
	/**final fields that represents types of objects on the board**/
	public final static int SHORE = 0; 
	public final static int WATER = 1; 
	public final static int GRASS = 2; 
	public final static int GRASS_L =3; 
	public final static int WALL = 4;
	public final static int GABION = 5;
	public final static int GABION_L = 6;
	public final static int GABION_2L = 7;
	
	
	public final static int TOTALROWS=6;
	
	public final static int RAISE=15; //how much high it is?
	
	/**final fields that represent the depth of the shore**/
	public final static int TOP_ROW1=3;
	public final static int TOP_ROW2=4*HEIGHT/TOTALROWS -RAISE ;
	public final static int TOP_ROW3=5*HEIGHT/TOTALROWS -2*RAISE;

	
	
	/**the array representing what was originally the shore**/
	public static int[][] beach = new int[3][SPACES_OF_SHORE]; //height, width
	
	//I KNOW NO IDEA WHAT THIS ACTUALLY IS
	/**the array representing the protectors**/
	public int[] posArr = {HEIGHT/2, TOP_ROW2, TOP_ROW3};
	
	/**how much time is left in the game**/
	int hoursLeft; 
	
	/**nano seconds per second conversion**/
	final static double NANOSECOND_PER_SECOND=1000000000.0;
	/**time when user starts playing**/
	final static long START_TIME= System.nanoTime();
	
	/**how much time has passed in seconds since user started playing**/
	public double elapsedTime=0;
	
	/**current Waves on the screen moving towards the shore**/
	private ArrayList<Wave> currWaves;
	private ArrayList<Wave> splitWaves;
	
	/**current Boats on the screen**/
	ArrayList<Boat> currBoats;
	
	/**current Turtles on the screen**/
	ArrayList<Turtle> turtles;
	
	/**the user**/
	public User user;
	
	/**the game should get easier as people keep losing**/
	int difficulty;
	
	private boolean turtleDie = false;
	public Wave newSplitWave1 = null;
	public Wave newSplitWave2 = null;
	public Wave newSplitWave3 = null;
	
	/**
	 * creates a new board of waves and protectors
	 * */
	public Board(){
		currBoats = new ArrayList<Boat>();
		setCurrWaves(new ArrayList<Wave>());
		splitWaves = new ArrayList<Wave>();
		user = new User();
		turtles = new ArrayList<Turtle>();
		hoursLeft = 24;
	}

	/**
	 * updates how much time has elapsed in the game in seconds
	 * */
	public void updateElapsedTime(){
		long currTime=System.nanoTime();
		elapsedTime = (currTime-START_TIME)/NANOSECOND_PER_SECOND;
		hoursLeft = (int) (elapsedTime /GAMESEC_PER_HOUR);
	}
	
	/**
	 * 
	 * @return true if player has lost, false if player has not lost
	 */
	public boolean checkLost(){
		Iterator<Turtle> turtleIt = turtles.iterator();
		while (turtleIt.hasNext()){
			Turtle turtle = turtleIt.next();
			if (turtle.getFramesLeft()<=0)
				turtleDie = true;
		}
		return (isShoreDestroyed||turtleDie);
	}
	
	/**
	 * creates a random new boat of a random variety
	 * Boats from most frequent to least frequent: Sailboat, Speedboats,and CruiseLiner
	 */
	public void createBoat(){
		int randomNum = 1 + (int)(Math.random() * 7);
		if (randomNum>0 && randomNum<4)
			currBoats.add(new Sailboat());
		else if(randomNum<=6)
			currBoats.add(new Speedboat());
		else
			currBoats.add(new CruiseLiner());
	}
	
	/**
	 * remove boats from list of current Boats to paint
	 */
	public void checkBoats(){
		Iterator<Boat> boatIt = getCurrBoats().iterator();
		while (boatIt.hasNext()){
			Boat currBoat = boatIt.next();
			if (currBoat.getXLoc()>WIDTH ||currBoat.getXLoc()<0){
				currBoats.remove(currBoat);
			}
		}
	}
	
	/**
	 * @param boat : the boat that creates the wave
	 * creates a new wave generated by the input parameter boat and adds it to the
	 * of arrayList of waves currently on the board
	 */
	public void createWave(Boat boat){
		getCurrWaves().add(new Wave(boat));
	}
	
	public void createTurtle(){
		turtles.add(new Turtle());
	}
	
	public int splitWave(Wave wave){
		//0: not split
		//1: split wave once
		//2: split wave twice
		int timesSplit = 0;
		boolean firstShore = true;;
		int water = 0;
		int waterLoc = 0;
		int shoreLoc = 0;
		boolean shoreAgain = false;
		int x = wave.getX();
		while (x < wave.getX()+wave.getLength()){
			try{
				if (beach[(int) (Math.ceil(wave.getY()*6/Board.HEIGHT))-3][x*SPACES_OF_SHORE/SHORE_WIDTH] == SHORE&&firstShore){
					firstShore=false;
				}
				if (beach[(int) (Math.ceil(wave.getY()*6/Board.HEIGHT))-3][x*SPACES_OF_SHORE/SHORE_WIDTH] == WATER && water == 0 && !firstShore){
					water++;
					waterLoc = x;
				}
			}catch(ArrayIndexOutOfBoundsException e){
				break;
			}
			if (water!= 0) //wave needs to be split at least once
				if (beach[(int) (Math.ceil(wave.getY()*6/Board.HEIGHT))-3][x*SPACES_OF_SHORE/SHORE_WIDTH] == SHORE && !shoreAgain){ //wave needs to be split twice
					shoreAgain = true;
					shoreLoc = x;
				}
			x++;
		}
		if (water ==1)
			System.out.println("shore water");
		if (shoreAgain)
			System.out.println("shore water shore");
		System.out.println("Shore is " + shoreLoc);
		if (water != 0){ //wave needs to be split
			timesSplit++;
			splitWaves.add(new Wave(wave.speed, waterLoc-wave.getX(), wave.getX(), wave.getY()));
			if (!shoreAgain){ //wave only needs to be split once
				splitWaves.add(new Wave(wave.speed, wave.getX()+wave.getLength()-waterLoc, waterLoc, wave.getY()));
			}
			else{ //wave needs to be split twice
				timesSplit++;
				splitWaves.add(new Wave(wave.speed, shoreLoc-waterLoc, shoreLoc, wave.getY()));
				splitWaves.add(new Wave(wave.speed, wave.getX()+wave.getLength()-shoreLoc, shoreLoc, wave.getY()));
			}
		}
		
		/*
		splitWaves.add(new Wave(wave.speed, wave.getLength()-wave.getX(), wave.getX(), wave.getY()));
		for (int i = left+1; i<right;i++){
			splitWaves.add(new Wave( wave.speed,SHORE_WIDTH/SPACES_OF_SHORE,i*SPACES_OF_SHORE,wave.getY()));
		}
		splitWaves.add(new Wave(wave.speed,wave.getLength()-(right-1)*SPACES_OF_SHORE,right*SPACES_OF_SHORE,wave.getY()));
		*/
		return timesSplit;
	}

	/**
	 * This method sets the beach grid when the wave hits the shore.  If the shore is already at
	 * the bottom of the screen, the shore is destroyed. If the wave hits the shore, that cell becomes 
	 * water. If the wave hits a protector, the cell becomes the shore.
	 * @param l the left most spot on the shore the wave hits
	 * @param r the right most spot on the shore the wave hits
	 */
	public void waveHit(int l, int r) {
		// where the leftmost and right most portion of the wave hits
		int left = (int) (SPACES_OF_SHORE * l / SHORE_WIDTH);
		int right = (int) (SPACES_OF_SHORE * r / SHORE_WIDTH);
		for (int i = left; i < right + 1; i++) {
			int depth = 0;
			try{
				while (depth < beach.length && beach[depth][i] == WATER && i<=SPACES_OF_SHORE) {
					depth++;
				}
			}catch(ArrayIndexOutOfBoundsException e){
				break;
			}
			if (depth == beach.length) // the shore has reached the bottom of the screen
				isShoreDestroyed = true;
			else if (beach[depth][i] == SHORE){
				beach[depth][i] = WATER;
				isInOcean(depth, i);
			}
			else if (beach[depth][i] != WATER || beach[depth][i] != SHORE) { //wave hits protector
				int protectorHit = beach[depth][i];
				if (protectorHit == GRASS_L || protectorHit == GABION_2L || protectorHit == GABION_L)
					beach[depth][i]--; // protector loses a life
				else
					beach[depth][i] = SHORE;
			}
		}
	}
	
	/**
	 * helper function to waveHit. If the wave hits while the user is in the ocean, changes the 
	 * isInOcean field to true so that when move() is called, the user can get out of the ocean
	 * @param depth is which row down on the shore the wave hit
	 * @param index is which column across on the shore the wave hit
	 */
	private void isInOcean(int depth, int index) {
		if (!user.isInOcean) {
			if (depth == 0) {
				if ((user.getyLoc() >= SHORE_HEIGHT && user.getyLoc() <= TOP_ROW2)
						|| user.getyLoc() + User.CRAB_HEIGHT >= SHORE_HEIGHT
								&& user.getyLoc() + User.CRAB_HEIGHT <= TOP_ROW2) {
					user.isInOcean = true;
				}
			}
			else if (depth == 1) {
				if ((user.getyLoc() >= TOP_ROW2 && user.getyLoc() <= TOP_ROW3)
						|| user.getyLoc() + User.CRAB_HEIGHT >= TOP_ROW2
								&& user.getyLoc() + User.CRAB_HEIGHT <= TOP_ROW3) {
					user.isInOcean = true;
				}
			}
			else if (depth == 2) {
				if ((user.getyLoc() >= TOP_ROW3 && user.getyLoc() <= HEIGHT)
						|| user.getyLoc() + User.CRAB_HEIGHT >= TOP_ROW3
								&& user.getyLoc() + User.CRAB_HEIGHT <= HEIGHT) {
					user.isInOcean = true;
				}
			}
		}
	}

	public void replaceProtector(int depth, int spot, int protector){
		if (beach[depth][spot]==GRASS || beach[depth][spot]==GABION || beach[depth][spot]==WALL)
			beach[depth][spot]=SHORE;
		else {
			beach[depth][spot]--;
		}
	}

	/**
	 * Returns the protector closest to the user by the user's position on the grid.
	 * @return the integer representing the protector chosen
	 */
	public int chooseProtector() {
		if ((int)(user.getxLoc()+user_width)*SPACES_OF_SHORE/SHORE_WIDTH == SPACES_OF_SHORE){
			if (user.getyLoc() <TOP_ROW2)
				protector = GRASS_L;
			else if (user.getyLoc() >= TOP_ROW2
					&& user.getyLoc() < TOP_ROW3)
				protector = GABION_2L; 
			else{
				protector = WALL;
			}
		}
		return protector;
	}
	
	
	
	/**
	 * Sets specific cell of beachgrid on the shoreline at user's xlocation to a protector.
	 */
	public void placeProtector(){
		int depth = 0;
		int spot = (int) user.getxLoc()*SPACES_OF_SHORE/SHORE_WIDTH;
		while (depth < beach.length && beach[depth][spot] != SHORE)
			depth++;
		beach[depth][spot] = getProtector();
		protector = -1;
	}
	
	
	/**
	 * @param x is the x location
	 * @param y is the y location
	 * @return whether or not the x and y location is a shore or not
	 */
	public static boolean isShore(double x, double y){
		if (x>0 && x<SHORE_WIDTH && y>SHORE_HEIGHT && y<HEIGHT-User.CRAB_HEIGHT){
			int crabSpot = (int)(SPACES_OF_SHORE*x/SHORE_WIDTH);
			int crabDepth = (int)(6*y/Board.HEIGHT);
			if (beach[crabDepth-3][crabSpot]!=WATER){
				return true;
			}
			return false;
		}
		return false;
	}
	
	/** @return the integer representing the current protector */
	public int getProtector(){return protector;}
	
	/**
	 * Returns the array of current boats on the screen.
	 * @return the array of current boats on the screen
	 */
	public ArrayList<Boat> getCurrBoats() {return currBoats;}
	
	/**
	 * Returns the width of the board.
	 * @return the width of the board
	 */
	public int getWidth(){return WIDTH;}
	
	/**
	 * Returns the height of the board.
	 * @return the height of the board
	 */
	public int getHeight(){return HEIGHT;}
	
	/**
	 * Returns the arraylist of current waves on the screen.
	 * @return the arraylist of current waves on the screen
	 */
	public ArrayList<Wave> getCurrWaves() {return currWaves;}
	
	public ArrayList<Wave> getSplitWaves(){return splitWaves;}
	/**
	 * Sets the attribute currWaves to the parameter currWaves.
	 * @param currWaves the arraylist to replace the attribute currWaves
	 */
	public void setCurrWaves(ArrayList<Wave> currWaves) {
		this.currWaves = currWaves;
	}
	
	public ArrayList<Turtle> getCurrTurtles(){
		return turtles;
	}
	public void addCurrWave(Wave wave){currWaves.add(wave);}
	
	public boolean getIsShoreDestroyed(){
		return isShoreDestroyed;
	}
	public void setIsShoreDestroyed(boolean x){
		System.out.println("changing boolean");
		isShoreDestroyed = x;
	}
	public void setTurtleDie(boolean x){
		turtleDie = x;
	}
}


